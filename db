database - 논리적인 data 저장소
dbms - 관리시스템(SW - process, memory)

- TableSpace (논리적으로 DB 다음으로 제일 큰 단위)
1) Meta저장소 (필수)
  - Table의 정보를 담고 있다
2) Undo 
  - 변경전 이력 내역을 관리한다
3) Temp 
  - Sort중간에 disk저장시 사용되는 

- Segment
- Extent
- Block

[인증방법]
1) 일방향 패스워드가 DB내에 저장
2) sys관리자계정은 패스워드 파일을 사용
3) os 로그온시에 DB인증
4) third party 인증

[ sqlplus 툴 접속 방법]
1) cmd> sqlplus / as sysdba -- sys계정으로 db접속
2) cmd> sqlplus sys/oracle as sysdba --sys계정으로 db접속
3) cmd> sqlplus /nolog --툴만 실행
SQL> conn sys/oracle as sysdba
SQL> alter user scott identified by oracle account unlock;
SQL> conn scott/oracle
SQL> select user from dual;
-- oracle은 select와 from 절이 필수절
-- mysql, ms-sql server는 단순계산, 상수, 함수결과 반환 받기 위해 select절만 사용합니다

data dictionary(meta) view
- user_xxxx (특정 db user 소유의 meta 정보)
- all_xxx (특정 db user 소유 + 권한 정보)
- dba_xxxx (dba 권한을 가진 user가 조회, 모든 정보 조회)
- v$_xxx (dba 권한을 가진 user가 성능관련 정보 조회)

SQL> select table_name from user_tables;
SQL> select table_name from all_tables;
SQL> select table_name from dba_tables; --권한 불충분
SQL> conn sys/oracle as sysdba
SQL> select count(table_name) from dba_tables;
SQL> conn scott/oracle
SQL> describe emp
SQL> desc dept


[Table 설명]
- Primary Key = NOT NULL + Unique
- heap table : partition 테이블로 ragne, hash, list로 나눌 수 있다.
- View : Talbe 의 window로 base table, View가 존재해야한다
  - 이유 : 
	  1) 보안상 2) 복잡한 sql 간결하게 쓰기 위해서 
  - 종류 :
	  1) symple(dml 가능) : 1개의 테이블  2) complex (dml 불가능) : join, 함수, grouping 포함된 경우

- Index : 검색 성능, 정확성 향상
  - 후보 컬럼은 where ,join에 자주 사용되어지는 컬럼
  - 보통 1 ~ 4개정도 선언한다. (primary, unique는 자동으로 index 생성)
  - DML 작업이 거의 없는 컬럼에 생성해주는게 적합하다 (CUD에 따라 tree를 유지해야되기 때문에)
  - 종류 : 1) 넓고 다양한 경우 btree
	   2) 10개정 도 사용되는 경우 bitmap


[sql 명령어]
sql 명렁어 키워드
sql plus 툴 명령어

테이블명, 컬럼명 naming 규칙
- 영문자, _, #으로 시작
- 두번째 문자부터 숫자 허용 
- 길이 제한 (30자) [db이름 8자]
- 대소문자 구별 안함 (db 메타정보 대문자 저장)
- 키워드 허용 안됨
- 스키마내에 동일 이름을 사용 안됨

describe 테이블명
char (고정 길이 문자열 ~ 2000btye), 
varchar2 (가변 길이 문자열 ~ 4000byte)
number (presition(전체 자리수), scale(소수점 자리수)) - [integer, float, binary_integer]
date - 세기, 년, 월, 일, 시, 분, 초
raw - binary 형식 (2000byte)
clob (character large of object) ~ 4GB
blob ~ 4GB
timestamp  
timestamp with timezone - timezone 까지 함께 저장
interval year to month
interval day to second 
rowid - 내장컬럼명 (논리적 행 주소 = objectid + fileid + blockid + row순서번호)


alter session set nls_date_format='YYYY-MM-dd HH24:MI:SS';

number 타입 컬럼 연산자 - 산술연산자


select * from emp where comm is null;
-- is null은 index를 연산하지 않는다

논리연산자 not and or


[sql 연산 순서]
select  -----5
from    -----1
where   -----2 (filter 조건)
group by -----3
having ----- 4
order by -----6

ORDER BY 컬럼 정렬방식(asc, desc)
ORDER BY 별칭 정렬방식(asc, desc)
ORDER BY 표현식 정렬방식(asc, desc)
ORDER BY 컬럼포지션 정렬방식(asc, desc)


select to_date('20년 6월 16일', 'YY"년" MM"월" DD"일"') from dual;


[NULL 처리 함수]
nvl(arg1, arg2)
nvl2(arg1, arg2, arg3) -- arg3 : NULL 일때 return
coalesce(arg1, ...... arg255) -- Null이 아닌 arg를 반환한다
nullif(arg1, arg2) -- 같으면 null를 return


[JOIN 조건]
where 조인 조건 선언 --- n-1 최소 조인 조건 선언중 1개라도 누락되면 cartesian product가 발생
from 조인 조건 선언
  - equi join (inner join) : PK와 FK 컬럼 조인조건
  - not equi join
  - self join (자기참조관계의 테이블 : 다른 테이블의 PK를 가지고 있는 경우)
  - outer join
  - cartesian product (cross join)

1) cartesian product
select e.empno, e.ename, e.deptno, d.dname
from emp e, dept d;
--- recursive sql수행을 줄이면(alias로 컬럼을 명시하는 경우) 성능 개선에 도움이 됩니다.
--- JOIN조건이 누락되면 cartesian product (조인할 테이블의 rows*rows의 결과 행)

2) equi join
select e.empno, e.ename, e.deptno, d.dname
from emp e ,dept d
where e.deptno = d.deptno;

3) natural join
select e.empno, e.ename, deptno, d.dname
from emp e natural join dept d;
--- natural join은 조인할 테이블에서 이름이 동일한 컬럼에 대해서 자동으로 equi 조인을 수행
동일한 이름의 컬럼은 소유자 테이블명, alias를 생략합니다.

natural or using 모델링 잘못 설계된 경우 -- 동일한 속성의 컬럼 이름을 다르게 설계, 컬럼타입을 다르게 설계
select e.empno, e.ename, deptno, d.dname
from emp e join dept d using (deptno);

create table t_emp
as select empno, ename, deptno as deptid from emp;

--- 컬럼 이름이 다를 경우 on절을 이용하여 JOIN
4) inner join
select e.empno, e.ename, d.deptno, d.dname
from t_emp e join dept d on e.deptid = d.deptno;

select e.empno, e.ename, d.deptno, d.dname
from emp e inner join dept d on e.deptno = d.deptno;


5) not equi join
select ename, sal, grade
from salgrade s INNER JOIN emp e
ON e.sal BETWEEN s.LOSAL AND s.HISAL


6) self join
select a.empno, a.ename, a.mgr, b.ename, b.hiredate
from emp a left join emp b
on a.mgr = b.empno;


n개의 테이블을 조인할 때 최소 조인조건은 n-1개
quiz> 사원이름(last_name), 부서이름(dname), 도시명


7) outer join
select e.empno, e.ename, e.deptno, d.dname
from emp e left outer join dept d
on e.deptno = d.deptno;

[join 수행 방식]
1. nested loop join (조인결과 소량) : 작은 테이블먼저 조인
2. hash join : 메모리 hashtable 기준으로 조인
3. sort merge join : PK, FK 각자 sort 후  row_id 별 같은 key로 정렬



select employee_id--, job_id, department_id
from employees
minus
select employee_id--, job_id, department_id
from job_history;
-- order by 절은 마지막 select 문에서만 사용 가능합니다
-- 각 select 문에서 선언하는 컬럼개수와 타입 일치해야 합니다

quiz> 전체사원의 급여 평균과
      부서별 사원의 급여 평균과
      직무별 사원들의 급여 평균과 
      부서와 직무별 사원들의 급여 평균을 단일 검색 결과로 
select to_number(null), to_char(null), avg(salary) from employees
union all
select department_id, to_char(null), avg(salary) from employees group by department_id 
union all
select department_id, job_id, avg(salary) from employees group by rollup(department_id, job_id);


group by cube(a,b, c)
-> group by a, b, c
-> group by a, b
-> group by a, c
-> group by b, c
-> group by a
-> group by b
-> group by c
-> group by ()


group by rollup(a,b,c)
-> group by a, b, c
-> group by a, b
-> group by a
-> group by ()

quiz> 관리자별 급여 평균과, 
	부서와 직무별 급여 평균과 
	전체 평균을 단일 결과로

select department_id, job_id, manager_id, avg(salary)
from employees
group by grouping sets ((manager_id), (department_id, job_id), ());





[sub query]

quiz> smith사원과 동일한 직무를 담당하는 사원들의 급여 조회 
select ename, sal   --- maing query, outer query
from emp
where job IN (
	select job 
	from emp
	where ename = 'SMITH' --subquery, nested query, inner query
)

subquery - where, from ,select, having, order by에 정의 가능

single row subquery 
mutiple row subquery 
scalar subquery 
mutiple column subquery (pair-wise 비교) 

co-related subquery (상관관계 subquery)




문> 사원번호 7839번과 동일한 직무를 담당하는 사원정보 검색
 

문> emp 테이블에서 최소 월급을 받는 사원 정보 검색
--subquery에 그룹함수 사용 가능 
 


문> emp 테이블에서 전체 사원 평균 월급보다 급여가 
적게 받는 사원 검색
 


문>EMP 테이블에서 사원번호가 7521인 사원과 업무가 같고 
급여가 7934인 사원보다 많은 사원의 사원번호, 이름, 담당업무, 입사일자, 급여를 조회하라.
--where절의 조건마다 subquery 사용 가능
 
 

문> EMP 테이블에서 부서별 최소 급여가 20번 부서의 최소 급여보다 
많은 부서를 조회하라.
 

문> EMP 테이블에서 업무별로 가장 적은 급여를 받는 사원  
조회하라
select job, ename from emp where (job, sal) IN (select job, min(sal) from emp group by job);


문> 10번부서 사원의 월급과 동일한 월급을 받는 다른 부서의 
사원을 검색하시오
select ename from emp where sal IN (select sal from emp where deptno = 10)
and deptno != 10;


문>업무가 SALESMAN인 사원중 최소 한명 이상의 사원보다 급여를 많이 받는 사원의 이름, 
급여, 업무를 조회하라
select ename, sal, job from emp where job <> 'SALESMAN' and sal > ANY (select sal from emp where job = 'SALESMAN');


문>업무가 SALESMAN인 모든 사원보다 급여를 많이 받는 사원의 이름, 
급여, 업무를 조회하라
select ename, sal, job from emp where sal > ALL (select sal from emp where job='SALESMAN');

 
문> 부서번호 50번 사원들중에서 월급이 높은 3사람을 조회하시오 (Top-N쿼리)
-- rowid (objectid+fileid+blockid+row순서번호) 
 select rownum, sal from (select sal, empno, ename from emp where deptno = 30 ORDER BY sal DESC) where rownum <= 3;


문>subquery를 사용해서 관리자인 사원들만 검색
 select ename from emp where empno IN (select  mgr from emp where mgr is not null);
 select ename from emp a where exists (select  * from emp where a.empno=mgr);
                                        ====> TRUE/FALSE만 반환한다.

문>subquery를 사용해서 관리자가 아닌 사원들만 검색
select ename from emp where empno not IN (select  mgr from emp where mgr is not null);
not IN ===> <> and <> and ...
select ename from emp a where not exists (select  mgr from emp where a.empno = mgr);
--subuery에서 null이포함되어 있는지 체크해서 main query에 영향을 주는지 여부도 체크해야 합니다.
 



문> 각 부서별로 평균급여보다 급여를 많이 받는 사원 검색 (이름, 부서, 급여)
1) correlated subquery (main쿼리의 후보 row가 sub로 들어가서 수행한다)
select ename, deptno, sal
from emp a 
where sal > (
	select avg(sal) as avg_sal
	from emp 
	where a.deptno = deptno
);

2) join
select a.ename, a.deptno, a.sal
from emp a
INNEr JOIN
(
	select deptno, avg(sal) as avg_sal
	from emp 
	group by deptno
) b
ON a.deptno = b.deptno
and a.sal > b.avg_sal





문> desc job_history (과거에 사원 근무 이력 )
두번 이상 부서 또는 직무를 변경한 이력이 있는 사원을 검색 (employees)
1) correlated subquery (main쿼리의 후보 row가 sub로 들어가서 수행한다)
select a.employee_id
from employees a
where 2 <= (
	select count(employee_id)
	from job_history
	where a.employee_id = employee_id
)


2) join
select a.employee_id
from employees a
INNER JOIN
(
	select employee_id, count(*) as cnt
	from job_history
	group by employee_id
	having count(*) >= 2
) b
ON a.employee_id = b.employee_id

[sub query 사용 장소]

create table ~ 
as select ~ 
   from ~;

view table ~ 
as select ~ 
   from ~;

insert into ~ values ~
insert into 
   select ~ 
   from ~;

insert into 테이블|뷰|(select ~ )
values ~

update 테이블 set 컬럼 = (scalar subquery)
where 컬럼 연산자 (subquery);

delete from 테이블 where 컬럼 연산자 (subquery);



[window function]
select empno, ename, job, sal, DENSE_RANK() OVER (ORDER BY sal DESC NULLS FIRST) "sal_rank" from emp;

dense_rank() 함수는 동일한 값의 레코드가 1개 이상이어도 하나의 순위로 취급 한다.
row_number() : 동일한 값에 대해서 개별적인 순위값을 반환 


[누적 합 구하기]
with order_sal as ( select empno, ename, deptno, sal from emp order by sal),
order_num as (select rownum rnum, empno, ename, deptno, sal from order_sal)
select empno, ename deptno, sal, (select sum(sal) from order_num where rnum <= a.rnum)
from order_num a;


[앞, 뒤 급여 평균]
select empno, mgr, sal, avg(sal) OVER (partition by mgr ORDER BY sal ASC ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)
from emp


select empno, mgr, sal, count(sal) OVER (ORDER BY sal ASC range BETWEEN 300 PRECEDING AND 300 FOLLOWING)
from emp

select deptno, empno, mgr, sal, 
	FIRST_VALUE(sal) OVER (partition by deptno ORDER BY sal DESC) "max_sal",
	LAST_VALUE(sal) OVER (partition by deptno ORDER BY sal DESC ROWS BETWEEN Current row and unbounded following) "min_sal"
from emp


select  ename, hiredate, sal, 
	lag(sal, 2, 0) over (order by hiredate) as prev_sal, 
	lead(sal, 2, 0) OVER (Order BY hiredate) as after_sal
from  emp



SELECT department_id, last_name, salary, PERCENT_RANK() 
       OVER (PARTITION BY department_id ORDER BY salary DESC) AS pr
  FROM employees
  ORDER BY pr, salary, last_name;



SELECT job_id, last_name, salary, CUME_DIST() 
  OVER (PARTITION BY job_id ORDER BY salary) AS cume_dist
  FROM employees

SELECT LISTAGG(last_name, '; ')
         WITHIN GROUP (ORDER BY hire_date, last_name) "Emp_list",
       MIN(hire_date) "Earliest"
  FROM employees
  WHERE department_id = 30;






